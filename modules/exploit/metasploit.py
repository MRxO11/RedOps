
"""
Direct Metasploit integration - use ANY Metasploit module
"""
import asyncio
import subprocess
import tempfile
import os
import re
from typing import List, Dict, Any

class MetasploitInterface:
    """Direct interface to Metasploit Framework"""
    
    @staticmethod
    def tool_exists():
        """Check if msfconsole is available"""
        return shutil.which("msfconsole") is not None
    
    @staticmethod
    async def search_modules(keyword: str, module_type: str = "exploit") -> List[Dict[str, str]]:
        """
        Search Metasploit modules by keyword
        Returns: List of module info dictionaries
        """
        if not MetasploitInterface.tool_exists():
            return []
        
        try:
           
            cmd = f"msfconsole -q -x 'search {keyword} type:{module_type}; exit'"
            process = await asyncio.create_subprocess_shell(
                cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                shell=True
            )
            
            stdout, stderr = await process.communicate()
            output = stdout.decode('utf-8', errors='ignore')
            
           
            modules = []
            lines = output.split('\n')
            
            for line in lines:
                
                if line.strip().startswith('exploit/') or line.strip().startswith('auxiliary/'):
                    parts = line.strip().split()
                    if len(parts) >= 3:
                        module_path = parts[0]
                        
                        name = module_path.split('/')[-1]
                        description = ' '.join(parts[2:]) if len(parts) > 2 else ""
                        
                        modules.append({
                            "path": module_path,
                            "name": name,
                            "type": module_path.split('/')[0],
                            "description": description[:100] + "..." if len(description) > 100 else description
                        })
            
            return modules
            
        except Exception as e:
            print(f"Search error: {e}")
            return []
    
    @staticmethod
    async def get_module_info(module_path: str) -> Dict[str, Any]:
        """
        Get detailed information about a Metasploit module
        """
        if not MetasploitInterface.tool_exists():
            return {"error": "msfconsole not found"}
        
        try:
            cmd = f"msfconsole -q -x 'use {module_path}; info; exit'"
            process = await asyncio.create_subprocess_shell(
                cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                shell=True
            )
            
            stdout, stderr = await process.communicate()
            output = stdout.decode('utf-8', errors='ignore')
            
            
            info = {
                "path": module_path,
                "name": module_path.split('/')[-1],
                "description": "",
                "options": [],
                "required_options": []
            }
            
            
            desc_match = re.search(r'Description:(.*?)(?=\n\n|\n       Name:)', output, re.DOTALL)
            if desc_match:
                info["description"] = desc_match.group(1).strip()
            
            
            options_section = False
            lines = output.split('\n')
            
            for line in lines:
                if "Module options:" in line or "Payload options:" in line:
                    options_section = True
                    continue
                
                if options_section and line.strip() and not line.startswith("   "):
                   
                    if "Current Setting" in line:
                        continue
                    
                    parts = line.strip().split()
                    if len(parts) >= 4:
                        option_name = parts[0]
                        required = parts[2] if len(parts) > 2 else "no"
                        description = ' '.join(parts[3:]) if len(parts) > 3 else ""
                        
                        info["options"].append({
                            "name": option_name,
                            "required": required.lower() == "yes",
                            "description": description
                        })
                        
                        if required.lower() == "yes":
                            info["required_options"].append(option_name)
            
            return info
            
        except Exception as e:
            return {"error": str(e)}
    
    @staticmethod
    async def execute_module(module_path: str, options: Dict[str, str], 
                           payload: str = None, timeout: int = 60) -> Dict[str, Any]:
        """
        Execute a Metasploit module with given options
        """
        if not MetasploitInterface.tool_exists():
            return {"success": False, "error": "msfconsole not found"}
        
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.rc', delete=False) as f:
            
            f.write(f"use {module_path}\n")
            
            for key, value in options.items():
                if value:
                    f.write(f"set {key} {value}\n")
            
            if payload:
                f.write(f"set payload {payload}\n")
            
            f.write("run\n")
            f.write("exit\n")
            rc_file = f.name
        
        try:
           
            cmd = f"msfconsole -q -r {rc_file}"
            
            process = await asyncio.create_subprocess_shell(
                cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                shell=True
            )
            
       
            try:
                stdout, stderr = await asyncio.wait_for(process.communicate(), timeout)
                output = stdout.decode('utf-8', errors='ignore')
                error = stderr.decode('utf-8', errors='ignore')
                
                
                success = any(indicator in output for indicator in 
                            ["Exploit completed", "Session created", "Meterpreter session", "Command shell session"])
                
               
                sessions = MetasploitInterface._parse_sessions(output)
                
                return {
                    "success": success,
                    "output": output,
                    "error": error,
                    "sessions": sessions,
                    "rc_file": rc_file  
                }
                
            except asyncio.TimeoutError:
                process.kill()
                return {"success": False, "error": "Timeout", "output": ""}
                
        except Exception as e:
            return {"success": False, "error": str(e), "output": ""}
            
        finally:
           
            try:
                os.unlink(rc_file)
            except:
                pass
    
    @staticmethod
    def _parse_sessions(output: str) -> List[Dict[str, str]]:
        """Parse Metasploit output for sessions"""
        sessions = []
        lines = output.split('\n')
        
        for line in lines:
            if "Meterpreter session" in line or "Command shell session" in line:
                
                match = re.search(r'session (\d+)', line)
                if match:
                    session_id = match.group(1)
                    session_type = "meterpreter" if "Meterpreter" in line else "shell"
                    
                   
                    target_match = re.search(r'\((.*?)\)', line)
                    target = target_match.group(1) if target_match else "unknown"
                    
                    sessions.append({
                        "id": session_id,
                        "type": session_type,
                        "target": target,
                        "raw": line.strip()
                    })
        
        return sessions
    
    @staticmethod
    async def list_payloads(platform: str = None) -> List[str]:
        """List available payloads"""
        if not MetasploitInterface.tool_exists():
            return []
        
        try:
            cmd = "msfconsole -q -x 'show payloads; exit'"
            if platform:
                cmd = f"msfconsole -q -x 'show payloads {platform}; exit'"
            
            process = await asyncio.create_subprocess_shell(
                cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                shell=True
            )
            
            stdout, stderr = await process.communicate()
            output = stdout.decode('utf-8', errors='ignore')
            
            payloads = []
            lines = output.split('\n')
            
            for line in lines:
                if line.strip() and "===" not in line and "Payloads" not in line:
                    parts = line.strip().split()
                    if parts and parts[0].startswith("payload/"):
                        payloads.append(parts[0])
            
            return payloads
            
        except Exception as e:
            return []
